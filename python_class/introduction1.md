# 클래스Class 란?

클래스는 파이썬에서 여러 객체를 생성해 이용할 때 중복되는 속성을 정의해두고 반복사용하는 방법
* class : 학급이 아니라 분류 Classification의 의미
* 무언가 공통된 특징을 갖는 묶음
   
## 클래스를 쓰는 이유

클래스는 공통적으로 쓰이는 코드를 손쉽게 재활용 및 재가공해서 쓰기 위해 반드시 필요하다.

함수와 유사하지만 함수보다 더 많은 내용을 담을 수 있으며, 훨씬 유연하다.

* 데이터를 하나만 담는 변수
* 데이터를 여러개 담는 리스트, 튜플, 딕셔너리
* 데이터를 받아 실행하는 함수
* 함수와 데이터를 묶어 동일코드 내에서 재사용하게 만들어주는 함수

클래스를 이용해 코딩하는 것을 **객체지향형 프로그래밍 Object-Oriented Programming** 이라고 한다.

## 클래스와 인스턴스

### 1. 클래스 기본형 만들어 보기

    class 참치선물세트:
        일반 = 0
        야채 = 0
        고추 = 0

위의 코드에서 **클래스명은 참치선물세트**이고, 이 세트의 구성품은 일반, 야채, 고추 세 종류이다.  
몇 개가 들어갈지는 아직 정해지지 않은 상황.

선물세트의 기본 틀만 만들어 둔 상황으로, 아직 아무 일도 일어나지 않음.

### 2. 인스턴스 이해하기

위에서 만들어둔 틀인 클랙스를 이용해 새로이 만들어질 **참치 선물세트 3호**를 **인스턴스**라고 함.  
즉, 찍어내는 틀은 **클래스**, 찍어낸 결과물은 **인스턴스**라고 부른다.  

### 3. 인스턴스 만들어 보기

    class 참치선물세트:
        일반 = 0
        야채 = 0
        고추 = 0

    참치3호세트 = 참치선물세트()

위와 같이 변수를 하나 설정하고, 거기에 값으로 클래스를 담으면 **참치 3호세트**라는 객체가 생성되고,   
이렇게 생성된 객체를 인스턴스라고 부른다.

그럼 여기에 3호 구성에 맞는 참치를 담아보자.

    class 참치선물세트:
        일반 = 0
        야채 = 0
        고추 = 0
        
    참치3호세트 = 참치선물세트()

    참치3호세트.일반 = 12
    참치3호세트.야채 = 3
    참치3호세트.고추 = 3

위의 코드에서 **일반, 야채, 고추**는 모두 **참치선물세트**라는 클래스 안에서 정의된 변수이다.   
참치세트 3호라는 인스턴스에 클래스를 이용해 내용물을 담고,  
점(.)을 찍어서 클래스 내부에 정의된 변수를 불러 값을 할당하는 것으로 클래스를 이용해 인스턴스를 생성할 수 있다.   
이제 참치3호 선물세트는 일반, 야채, 고추 참치를 담고있다. 

### 4. LoL의 캐릭터를 클래스로 정의해 보자
LoL의 모든 캐릭터는 공통으로 갖고있는 특징이 있다.
바로 **체력, 공격력, 이동속도**이다.

그럼 모든 캐릭터가 갖고있는 이 속성을 클래스로 정의하고, 캐릭터 인스턴스를 생성해 보자.   
그리고, 내용물을 확인해 보려면 print문을 사용하면 된다.

    class Units:
        hp = 0
        damage = 0
        speed = 0
    
    timo = Units()
    timo.hp = 10
    timo.damage = 100
    timo.speed = 50

    yasuo = Units()
    yasuo.hp = 5
    yasuo.damage = 1000
    yasuo.speed = 100

    print("티모 - 체력 : {0} | 공격력 : {1} | 이속 : {2}".format(timo.hp, timo.damage, timo.speed))

# 클래스와 함수(메소드 method)
모든 프로그램은 **함수**로 이뤄져 있다고 해도 과언이 아니다. 클래스가 없는 프로그램은 있을 수 있지만, 함수가 없는 프로그램은 찾기 어려울 것이다.  
하지만, 클래스와 함수가 함께 만나면 프로그램은 날개를 달게 된다.  
클래스 안에 함수를 정의하면 단순한 변수의 입출력 뿐만 아니라 다양한 상호작용이 가능하기 때문이다.

    class 참치선물세트:
        일반 = 0
        야채 = 0
        고추 = 0

        def 총합(self, 이름):
            내용물갯수 = self.일반 + self.야채 + self.고추
            return 이름 + str(내용물갯수)

위의 예시에서는 **참치선물세트**라는 클래스 안에,   
각각 담기는 참치캔의 갯수를 모두 더하는 함수를 추가했다.   
그 함수의 이름은 **총합**이다.

함수의 형태는 우리가 기존에 쓰던 것과 크게 다르지 않지만,   
매개변수중 맨 앞에 **self**라는 것이 추가되어 있는점이 다르다.

여기서 **self**는 클래스 안에 정의된 변수를 지칭하기 위해 쓰는 호출값이다.   
이렇게 하는 이유는, 클래스의 메소드(함수)는 다양한 값과 상호작용해야 하는데,   
클래스 안에 정의된 함수도 있고, 클래스 밖에서 쓰이는 함수도 있을 때 이들을 모두 이용하되,   
클래스 내부의 함수를 구분해 쓸 수 있는 도구이다.

### 그럼 클래스 안에 정의된 메소드(함수)를 호출하는 방법을 알아보자.
    class 참치선물세트:
        일반 = 0
        야채 = 0
        고추 = 0

        def 총합(self, 이름):
            내용물갯수 = self.일반 + self.야채 + self.고추
            return 이름 + str(내용물갯수)
    참치1호 =  참치선물세트()
    참치1호.일반 = 5
    참치1호.야채 = 3
    참치1호.고추 = 2

    참치갯수 = 참치1호.총합("담긴 참치 갯수 : ")

    print(참치갯수)

실행해보면 **담긴 참치 갯수 : 10** 이라는 결과를 얻을 수 있다.   
하지만, 우리가 알던 함수와 사용법이 다르다.   
**참치1호**라는 인스턴스에 담긴 **총합**이라는 함수를 호출한다면,   
정의된 내용에서 보면 넘겨받아야 하는 매개변수는 2개이다. (self, 이름)    

하지만 함수를 호출할 때에는 **문자열("담긴 참치 갯수 : )**만 넣어줬다.  
그런데도 코드가 이상없이 작동하였다.  
문제는 뭘까? 바로 **self**라는 매개변수가 갖는 특징 때문이다.

> 클래스 안에 정의되는 메소드(함수)에서, self 라는 매개변수는 클래스 안에서 만들어진 변수를 부를 때 쓰는 호출기호일 뿐,  
메소드(함수)를 사용할 때는 '없는 값'으로 취급한다. 

여기에서 참치갯수라는 변수를 만든 이유는, 클래스 안에 정의된 메소드 "총합"의 코드 안에 return이 포함되었기 때문이다.

### 그렇다면 리턴값을 넣지 않고 어떻게 출력할 수 있을까?

    class 참치선물세트:
        일반 = 0
        야채 = 0
        고추 = 0

        def 총합(self, 이름):
            내용물갯수 = self.일반 + self.야채 + self.고추
            print("이름" + str(내용물갯수))
    참치1호 =  참치선물세트()
    참치1호.일반 = 5
    참치1호.야채 = 3
    참치1호.고추 = 2

    참치1호.총합("담긴 참치 갯수 : ")

위와 같이 값을 돌려줄 필요가 없이 내용물만 확인하고자 할땐,   
print 명령어를 함수 내부에 두고 활용이 가능하다.

## self는 변수뿐 아니라 클래스 내부의 다른 메소드(함수)도 호출할 수 있다.

    class 참치선물세트:
        일반 = 0
        야채 = 0
        고추 = 0

        def 총합(self, 이름):
            내용물갯수 = self.일반 + self.야채 + self.고추
            print("이름" + str(내용물갯수))

        def 출력(self):
            self.총합("담긴 참치 갯수 : ")
    
    참치1호 =  참치선물세트()
    참치1호.일반 = 5
    참치1호.야채 = 3
    참치1호.고추 = 2

    참치1호.출력()

위의 예시에서 두 번째 메소드(함수)는 첫 번째 메소드(함수)를 호출하는 내용이다.  
**self.**이후에 메소드의 이름을 적고, 첫 번째 메소드에서 필요한 매개변수를 넣어주면  
앞선 예제와 똑같은 결과를 얻을 수 있다.

> 이렇듯, **self**라는 매개변수는 실제로 매개변수로 기능하는 것이 아니라,  
클래스 내의 다양한 객체(변수, 메소드)를 콕 찝어 불러올 때 쓰는 호출문이다.

# 귀차니즘 극복을 위한 도구, 생성자 **__init__**

앞의 예제에서, 참치선물세트 클래스 안에는 3개의 변수가 들어있었다.  
그리고, 참치선물세트 클래스로 인스턴스를 생성할 때는 3줄에 걸쳐  
각각의 변수에 값을 대입해 넣었다. 이건 너무 귀찮지 않나?

그래서 파이썬에서는 클래스 안에서 변수를 선언하고 그 클래스를 이용해  
인스턴스를 생성할 때 보다 간편한 방식을 제공한다. 아니, 이 방식이 표준이다.

    class 참치선물세트():
        def __init__(self, 일반, 야채, 고추):
            self.일반 = 일반
            self.야채 = 야채
            self.고추 = 고추

        def 내용물보기(self, name):
            print(name)
            print("일반참치 : " + str(self.일반))
            print("야채참치 : " + str(self.야채))
            print("고추참치 : " + str(self.고추))    

    참치1호 = 참치선물세트(10, 3, 2)
    참치1호.내용물보기("참치1호 내용물 안내")

위의 코드에서 참치선물세트의 초기값은 __init__이라는 메소드로 정의하였다.  
여기에서 self를 제외한 매개변수는 메소드 안에서 별도의 변수선언과정 없이 모두 변수로 만들어지고, 즉시 값이 입력된다.

불편한 변수선언의 과정을 _ _ init _ _이라는 생성자를 통해 한 방에 해결하는 것이다.  
여기서 init은 initialize의 줄임말로, 초기값을 설정한다는 뜻을 갖는다.

즉, 클래스를 정의할 때 가장 먼저 정의되는 메소드는 바로 _ _ init _ _이라는 방법을 통하며,  
클래스를 이용해 만들 인스턴스에 필요한 변수와 변수에 담길 값을 모두 여기에서 처리하는 것이다.

이렇게 하면 인스턴스를 생성하는 코드를 확 출일 수 있다.  
이전의 예제와 비교해 보면,

    # 기존의 인스턴스 생성코드
    참치1호 =  참치선물세트()
    참치1호.일반 = 5
    참치1호.야채 = 3
    참치1호.고추 = 2

    # __init__ 생성자를 활용한 인스턴스 생성코드
    참치1호 = 참치선물세트(10, 3, 2)

코드의 양이 엄청 줄어드는 걸 볼 수 있다.

> init 이외에도 파이썬의 클래스에서는 언더바 두개(_ _)를 앞뒤로 감싸는 것들 **매직 메소드**라고 부른다.  
2개의 언더바는 파이썬 내에서 클래스에서 쓰이는 매직 메소드만을 위해 쓰이므로 변수나 함수등의 이름 앞뒤에 붙이지 말자.