# 클래스 본격 활용하기

## 1. 상속과 슈퍼클래스, 서브클래스

참치 선물세트에 스팸과 올리브유를 넣으면 더 잘 팔린다는 마케팅 부서의 요청에 따라 새로운 선물세트를 만들어야 한다.   
기존에 참치선물세트라는 틀을 만들어두었는데, 여기에 올리브유를 어떻게 넣을까?  
틀을 새로 만들어야 할까?  

이럴때, 기존의 클래스에 새로운 요소를 추가해 넣을 수 있는 방법이 있다.  
바로 **상속**을 통해 클래스의 한계를 확장하는 것이다.

    class 참치선물세트():
        def __init__(self, 일반, 야채, 고추):
            self.일반 = 일반
            self.야채 = 야채
            self.고추 = 고추
    
    class 특별선물세트(참치선물세트):
        pass

위의 예제에서 **특별선물세트** 클래스는 기본적으로 **참치선물세트**의 기본속성을 받아온다.  
pass로 내용을 비워두었더라도 특별선물세트는 참치선물세트로부터 변수와 매서드를 받아온다.  
이때, **참치선물세트**는 **특별선물세트**의 상위 클래스이므로 **슈퍼 클래스 Super Class**라고 부르고,  
상속받는 **특별선물세트**는 **참치선물세트**의 **서브 클래스 Sub Class**라고 부른다.
그리고, **특별선물세트**는 슈퍼클래스인 참치선물세트의 내용물들(변수와 매서드)을 **상속**받게 된다.

아래의 코드는 실제로 상위클래스를 상속받되, 자신이 필요한 내용물만 가져오고 나머지는 새로 만드는 방법을 보여준다.

    class 참치선물세트():
        def __init__(self, 일반, 야채, 고추):
            self.일반 = 일반
            self.야채 = 야채
            self.고추 = 고추

        def 내용물보기(self, name):
            print(name)
            print("일반참치 : " + str(self.일반))
            print("야채참치 : " + str(self.야채))
            print("고추참치 : " + str(self.고추))  
    
    class 특별선물세트(참치선물세트):
        def __init__(self, 일반, 스팸, 올리브유):
            super().__init__(일반, 0, 0)
            self.스팸 = 스팸
            self.올리브유 = 올리브유


위처럼 참치선물세트를 기본으로, 스팸과 올리브유가 새롭게 추가되는 클래스를 만들었다.  
그러면 이 클래스를 사용해서 실제로 새로운 객체(인스턴스)를 만들어 보자.

    class 참치선물세트():
        def __init__(self, 일반, 야채, 고추):
            self.일반 = 일반
            self.야채 = 야채
            self.고추 = 고추

        def 내용물보기(self, name):
            print(name)
            print("일반참치 : " + str(self.일반))
            print("야채참치 : " + str(self.야채))
            print("고추참치 : " + str(self.야채))  
    
    class 특별선물세트(참치선물세트):
        def __init__(self, 일반, 스팸, 올리브유):
            super().__init__(일반, 0, 0) #상위클래스의 생성자(init)에서 3개의 변수 중 1개만 가져옴
            self.스팸 = 스팸 #특별선물세트에서만 쓰는 변수 만들기
            self.올리브유 = 올리브유 #특별선물세트에서만 쓰는 변수 만들기

    특별01 = 특별선물세트(6, 3, 2)
    특별01.내용물보기("특별세트 1호")

위의 코드는 **특별01** 이라는 객체(인스턴스)를 특별선물세트라는 클래스로 생성한 뒤,  
내용물이 무엇인지 알아보는 코드이다.  

    특별01.내용물보기("특별세트 1호")

의 코드에서 **내용물보기**매서드는 특별선물세트의 슈퍼클래스인 참치선물세트의 매서드이다.  
특별선물세트가 참치선물세트를 상속했으므로 슈퍼클래스의 매서드를 그대로 가져다 쓸 수 있는것이다.  
그런데 출력의 결과를 보면 새로이 추가된 스팸과 올리브유의 갯수는 보여주지 않는다.  
**내용물보기** 매서드를 보면 기존의 참치선물세트의 목록만 출력하도록 작성되었기 때문이다.

## 2. 매서드 오버라이드 (함수 덮어쓰기?!)
위의 코드에서 우리가 새롭게 추가한 품목인 스팸과 올리브유까지 확인하려면  
**내용물보기** 매서드를 고쳐줄 필요가 있다.
매서드의 내용을 모두 새롭게 짤 필요없이 추가되는 항목만 덧붙여주면 된다.

        # 기존코드

        def __init__(self, 일반, 야채, 고추):
            self.일반 = 일반
            self.야채 = 야채
            self.고추 = 고추

        def 내용물보기(self, name):
            print(name)
            print("일반참치 : " + str(self.일반))
            print("야채참치 : " + str(self.야채))
            print("고추참치 : " + str(self.야채))  
    
    class 특별선물세트(참치선물세트):
        def __init__(self, 일반, 스팸, 올리브유):
            super().__init__(일반, 0, 0) #상위클래스의 생성자(init)에서 3개의 변수 중 1개만 가져옴
            self.스팸 = 스팸 #특별선물세트에서만 쓰는 변수 만들기
            self.올리브유 = 올리브유 #특별선물세트에서만 쓰는 변수 만들기


        # 내용물보기 매서드를 새롭게 정의

        def 내용물보기(self, name):
            super().내용물보기(name)
            print("스팸 : " + str(self.스팸))
            print("올리브유 : " + str(self.올리브유))

    특별01 = 특별선물세트(6, 3, 2)
    특별01.내용물보기("특별세트 1호")

이렇게 메서드를 새롭게 정의할 때 특이한 점은,  
**슈퍼클래스의 매서드와 동일한 이름으로 서브클래스의 메서드를 만든다**는 점이다.

## 도전과제

> LoL에서 움직이는 캐릭터를 클래스로 정의하여 미니언을 생성하고, 서브클래스인 챔피언을 생성하여 Q, W, E, R 매서드를 추가해 공격력이 얼마인지 표시해 보자